#include "Precomp.h"
#include "Raytracer.h"
#include "RaytraceCS.h" // generated by compiling hlsl
#include "Debug.h"

std::unique_ptr<Raytracer> Raytracer::Create(HWND window)
{
    std::unique_ptr<Raytracer> raytracer(new Raytracer(window));
    if (raytracer)
    {
        if (raytracer->Initialize())
        {
            return raytracer;
        }
    }

    return nullptr;
}

Raytracer::Raytracer(HWND hwnd)
    : Window(hwnd)
    , hFov(0.f)
    , DistToProjPlane(0.f)
{
    assert(Window);

    RECT clientRect = {};
    GetClientRect(Window, &clientRect);

    Width = clientRect.right - clientRect.left;
    Height = clientRect.bottom - clientRect.top;
    HalfWidth = Width * 0.5f;
    HalfHeight = Height * 0.5f;
}

Raytracer::~Raytracer()
{
}

void Raytracer::SetFOV(float horizFovRadians)
{
    hFov = horizFovRadians;
    float denom = tanf(hFov * 0.5f);
    assert(!isnan(denom) && fabsf(denom) > 0.00001f);
    DistToProjPlane = (Width * 0.5f) / denom;
}

bool Raytracer::Render(FXMMATRIX cameraWorldTransform, bool vsync)
{
    Clear();

    // Update constants
    D3D11_MAPPED_SUBRESOURCE mapped = {};
    HRESULT hr = Context->Map(CameraDataCB.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped);
    if (FAILED(hr))
    {
        LogError(L"Failed to map constant buffer for writing.");
        return false;
    }

    CameraData* camera = (CameraData*)mapped.pData;
    XMStoreFloat4x4(&camera->CameraWorldTransform, cameraWorldTransform);
    camera->HalfSize = XMFLOAT2(HalfWidth, HalfHeight);
    camera->DistToProjPlane = DistToProjPlane;
    Context->Unmap(CameraDataCB.Get(), 0);

    Context->Dispatch(Width / 4, Height / 4, 1);

    return Present(vsync);
}

bool Raytracer::Initialize()
{
    UINT d3dFlag = 0;
#if defined(_DEBUG)
    d3dFlag = D3D11_CREATE_DEVICE_DEBUG;
#endif

    D3D_FEATURE_LEVEL featureLevel = D3D_FEATURE_LEVEL_11_0;

    DXGI_SWAP_CHAIN_DESC scd = {};
    scd.BufferCount = 2;
    scd.BufferDesc.Width = Width;
    scd.BufferDesc.Height = Height;
    scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT | DXGI_USAGE_UNORDERED_ACCESS;
    scd.OutputWindow = Window;
    scd.SampleDesc.Count = 1;
    scd.Windowed = TRUE;

    HRESULT hr = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr,
        d3dFlag, &featureLevel, 1, D3D11_SDK_VERSION, &scd, &SwapChain, &Device, nullptr,
        &Context);
    if (FAILED(hr))
    {
        LogError(L"Failed to create graphics device and swapchain.");
        return false;
    }

    // Get back buffer
    ComPtr<ID3D11Texture2D> texture;
    hr = SwapChain->GetBuffer(0, IID_PPV_ARGS(&texture));
    if (FAILED(hr))
    {
        LogError(L"Failed to get backbuffer.");
        return false;
    }

    // Create UAV for compute access
    hr = Device->CreateUnorderedAccessView(texture.Get(), nullptr, &RenderTargetUAV);
    if (FAILED(hr))
    {
        LogError(L"Failed to create render target uav.");
        return false;
    }

    // Create compute shader
    hr = Device->CreateComputeShader(RaytraceCS, _countof(RaytraceCS), nullptr, &ComputeShader);
    if (FAILED(hr))
    {
        LogError(L"Failed to create compute shader.");
        return false;
    }

    // Bind the shader
    Context->CSSetShader(ComputeShader.Get(), nullptr, 0);

    // Bind the Render Target UAV
    UINT count = 0;
    Context->CSSetUnorderedAccessViews(0, 1, RenderTargetUAV.GetAddressOf(), &count);

    // Create the constant buffer
    D3D11_BUFFER_DESC bd = {};
    bd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
    bd.ByteWidth = sizeof(CameraData);
    bd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
    bd.StructureByteStride = bd.ByteWidth;
    bd.Usage = D3D11_USAGE_DYNAMIC;

    hr = Device->CreateBuffer(&bd, nullptr, &CameraDataCB);
    if (FAILED(hr))
    {
        LogError(L"Failed to create constant buffer.");
        return false;
    }

    // Load the Environment map
    TexMetadata metadata;
    std::unique_ptr<ScratchImage> image(new ScratchImage);
    hr = LoadFromDDSFile(L"Environment.dds", DDS_FLAGS_NONE, &metadata, *image);
    if (FAILED(hr))
    {
        LogError(L"Failed to load environment map texture.");
        return false;
    }

    assert(metadata.dimension == TEX_DIMENSION_TEXTURE2D && metadata.IsCubemap());

    ComPtr<ID3D11Resource> resource;
    hr = CreateTextureEx(Device.Get(), image->GetImages(), image->GetImageCount(), metadata,
                         D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE, 0,
                         D3D11_RESOURCE_MISC_TEXTURECUBE, false, &resource);
    if (FAILED(hr))
    {
        LogError(L"Failed to create texture from DDS.");
        return false;
    }

    hr = resource.As(&EnvTexture);
    if (FAILED(hr))
    {
        LogError(L"Failed to query texture interface.");
        return false;
    }

    hr = Device->CreateShaderResourceView(EnvTexture.Get(), nullptr, &EnvMapSRV);
    if (FAILED(hr))
    {
        LogError(L"Failed to create env map srv.");
        return false;
    }

    D3D11_SAMPLER_DESC sd = {};
    sd.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
    sd.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
    sd.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
    sd.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
    hr = Device->CreateSamplerState(&sd, &EnvMapSampler);
    if (FAILED(hr))
    {
        LogError(L"Failed to create env map sampler.");
        return false;
    }

    // Bind the environment map & sampler
    Context->CSSetShaderResources(0, 1, EnvMapSRV.GetAddressOf());
    Context->CSSetSamplers(0, 1, EnvMapSampler.GetAddressOf());

    // Bind the constant buffer
    Context->CSSetConstantBuffers(0, 1, CameraDataCB.GetAddressOf());

    if (!GenerateTestScene())
    {
        LogError(L"Failed to create test scene.");
        return false;
    }

    return true;
}

void Raytracer::Clear()
{
    // Clear out the buffer
    static const float clearColor[] = { 0.f, 0.f, 0.4f, 1.f };
    Context->ClearUnorderedAccessViewFloat(RenderTargetUAV.Get(), clearColor);
}

bool Raytracer::Present(bool vsync)
{
    HRESULT hr = SwapChain->Present(vsync ? 1 : 0, 0);
    if (FAILED(hr))
    {
        LogError(L"Failed to present.");
        return false;
    }

    return true;
}

bool Raytracer::GenerateTestScene()
{
    //
    // Spheres
    //
    std::vector<SphereObject> spheres;

    SphereObject obj;
#if 1

    // drop in 20 random spheres
    for (int i = 0; i < 20; ++i)
    {
        obj.Center = XMFLOAT3(rand() / (float)RAND_MAX * 10.f - 5.f,
                              rand() / (float)RAND_MAX * 10.f - 5.f,
                              rand() / (float)RAND_MAX * 10.f - 5.f);
        obj.Radius = rand() / (float)RAND_MAX * 1.f + 0.5f;
        obj.Color = XMFLOAT3(rand() / (float)RAND_MAX * 0.75f + 0.25f,
                             rand() / (float)RAND_MAX * 0.75f + 0.25f,
                             rand() / (float)RAND_MAX * 0.75f + 0.25f);
        obj.Reflectiveness = 0.f;
        spheres.push_back(obj);
    }

#else
    obj.Center = XMFLOAT3(0.f, 0.f, 0.f);
    obj.Radius = 1.5f;
    obj.Color = XMFLOAT3(0.4f, 0.4f, 0.4f);
    obj.Reflectiveness = 2.f;
    spheres.push_back(obj);

    obj.Center = XMFLOAT3(-1.f, -1.f, -2.f);
    obj.Radius = 0.25f;
    obj.Color = XMFLOAT3(1.f, 0.f, 0.f);
    obj.Reflectiveness = 0.f;
    spheres.push_back(obj);

    obj.Center = XMFLOAT3(1.f, 0.f, -2.f);
    obj.Radius = 0.5f;
    obj.Color = XMFLOAT3(0.f, 0.f, 1.f);
    obj.Reflectiveness = 0.f;
    spheres.push_back(obj);
#endif

    // Create buffer to hold the scene's sphere
    D3D11_BUFFER_DESC bd = {};
    bd.BindFlags = D3D11_BIND_SHADER_RESOURCE;
    bd.ByteWidth = sizeof(SphereObject) * (int)spheres.size();
    bd.StructureByteStride = sizeof(SphereObject);
    bd.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
    bd.Usage = D3D11_USAGE_DEFAULT;

    // Initialize the sphere buffer with the spheres
    D3D11_SUBRESOURCE_DATA init = {};
    init.pSysMem = spheres.data();
    init.SysMemPitch = bd.ByteWidth;
    init.SysMemSlicePitch = init.SysMemPitch;

    HRESULT hr = Device->CreateBuffer(&bd, &init, &SphereObjects);
    if (FAILED(hr))
    {
        LogError(L"Failed to create sphere object buffer.");
        return false;
    }

    // Create shader resource so we can read from it in the shader
    D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
    srvDesc.Format = DXGI_FORMAT_UNKNOWN;
    srvDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
    srvDesc.Buffer.ElementWidth = sizeof(SphereObject);
    srvDesc.Buffer.NumElements = (int)spheres.size();

    hr = Device->CreateShaderResourceView(SphereObjects.Get(), &srvDesc, &SphereObjectsSRV);
    if (FAILED(hr))
    {
        LogError(L"Failed to create sphere object buffer srv.");
        return false;
    }

    // Bind it at slot 1 (after the env map)
    Context->CSSetShaderResources(1, 1, SphereObjectsSRV.GetAddressOf());

    //
    // Lights
    //
    std::vector<PointLight> lights;

    PointLight light;
    light.Position = XMFLOAT3(1.f, 3.f, -4.f);
    light.Color = XMFLOAT3(0.6f, 0.6f, 0.6f);
    light.Radius = 5.f;
    lights.push_back(light);

    //light.Position = XMFLOAT3(-3.f, 0.f, -3.f);
    //light.Color = XMFLOAT3(0.6f, 0.6f, 0.6f);
    //light.Radius = 5.f;
    //lights.push_back(light);

    // Create light buffer
    bd.BindFlags = D3D11_BIND_SHADER_RESOURCE;
    bd.ByteWidth = sizeof(PointLight) * (int)lights.size();
    bd.StructureByteStride = sizeof(PointLight);
    bd.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
    bd.Usage = D3D11_USAGE_DEFAULT;

    // Initialize the light buffer with the lights
    init.pSysMem = lights.data();
    init.SysMemPitch = bd.ByteWidth;
    init.SysMemSlicePitch = init.SysMemPitch;

    hr = Device->CreateBuffer(&bd, &init, &PointLights);
    if (FAILED(hr))
    {
        LogError(L"Failed to create light buffer.");
        return false;
    }

    // Create shader resource so we can read from it in the shader
    srvDesc.Format = DXGI_FORMAT_UNKNOWN;
    srvDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
    srvDesc.Buffer.ElementWidth = sizeof(PointLight);
    srvDesc.Buffer.NumElements = (int)lights.size();

    hr = Device->CreateShaderResourceView(PointLights.Get(), &srvDesc, &PointLightsSRV);
    if (FAILED(hr))
    {
        LogError(L"Failed to create point light srv.");
        return false;
    }

    // Bind it at slot 2 (after spheres)
    Context->CSSetShaderResources(2, 1, PointLightsSRV.GetAddressOf());

    return true;
}
